function alms = rotate_alm(rotate, alms, lmax, mmax)
% alms = rotate_alms(rotate, alms, lmax, mmax)
% INPUTS
%   rotate      Rotation to perform. Valid specifications are:
%               1. A pair of characters among 'C', 'E', & 'G' to indicate
%                  transforming from/to celestial (equatorial), ecliptic, and
%                  galactic coordinates (all J2000), respectively.
%
%               2. A scalar integer from the following list:
%                      1 = Equatorial (2000) -> Galactic   (2000)
%                      2 = Galactic   (2000) -> Equatorial (2000)
%                      3 = Equatorial (2000) -> Ecliptic   (2000)
%                      4 = Ecliptic   (2000) -> Equatorial (2000)
%                      5 = Ecliptic   (2000) -> Galactic   (2000)
%                      6 = Galactic   (2000) -> Ecliptic   (2000)
%                      7 = Equatorial (1950) -> Galactic   (1950)
%                      8 = Galactic   (1950) -> Equatorial (1950)
%                      9 = Equatorial (1950) -> Ecliptic   (1950)
%                     10 = Ecliptic   (1950) -> Equatorial (1950)
%                     11 = Ecliptic   (1950) -> Galactic   (1950)
%                     12 = Galactic   (1950) -> Ecliptic   (1950)
%
%   alms        A Nx1 or Nx3 complex matrix of spherical harmonic coefficients.
%   lmax        Maximum degree of spherical harmonics. Optional if
%               alm_getlmmax() can infer lmax from the size of alms.
%   mmax        Maximum order of spherical harmonics. Optional if
%               alm_getlmmax() can infer mmax fromthe size of alms.
%
% OUTPUTS
%   alms        The given alms after coordinate rotation.
%
% EXAMPLE

  if ~exist('lmax', 'var')
    lmax = [];
  end
  if ~exist('mmax', 'var')
    mmax = [];
  end

  [lmax, mmax] = @CLASSPREFIX@alm_getlmmax(alms, lmax, mmax);

  if size(alms, 2) == 1
    % T-only alms - pass through empty/dummy complex alms as almsG & almsC
    almsT = alms;
    almsG = complex(double([]));
    almsC = complex(double([]));
  elseif size(alms, 2) == 3
    % T + Pol alms case
    almsT = alms(:,1);
    almsG = alms(:,2);
    almsC = alms(:,3);
  else
    error('alms: Expected size 1 or 3 in second dimension, got %d', ...
        size(alms, 2));
  end

  % Rotate by coordinate transformation name
  if ischar(rotate)
    if length(rotate) ~= 2
      error('rotate string must be two characters')
    end
    if ~any(upper(rotate(1))=='CEG') || ~any(upper(rotate(2))=='CEG')
      error('Only ''C'', ''E'', and ''G'' rotations are supported')
    end
    % abbreviations for the first 6 numbered transforms
    itransforms = {'CG', 'GC', 'CE', 'EC', 'EG', 'GE'};
    rotate = strmatch(rotate, itransforms, 'exact');
    [almsT,almsG,almsC] = rotate_alms_coord(rotate, lmax, mmax, almsT, almsG, almsC);

  % Rotate by coordinate transformation ID number
  elseif isscalar(rotate) && fix(rotate) == rotate
    [almsT,almsG,almsC] = rotate_alms_coord(rotate, lmax, mmax, almsT, almsG, almsC);
  else
    error('Invalid rotation specification')
  end

  if size(alms, 2) == 1
    alms = almsT;
  else
    alms = [almsT almsG almsC];
  end
end

function [almsT,almsG,almsC] = rotate_alms_coord(transform, lmax, mmax, almsT, almsG, almsC)
  if transform < 0 || transform > 12
    error('Invalid coordinate transform specificiation: %d', transform);
  end
  [almsT,almsG,almsC] = libhealmex(int64(65), ...
      int32(transform), int32(lmax), int32(mmax), ...
      almsT, almsG, almsC);
end
