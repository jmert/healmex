function maps = alm2map_der1(alms, nside, varargin)
% maps = alm2map_der1(alms, nside, varargin)
%
% Synthesizes a map and its first derivatives from the provided alms at
% Nisde = nside with RING ordered pixelization.
%
% INPUTS
%   alms    The spherical harmonic coefficients of a map.
%
%   nside   HEALPix Nside of output map to synthesize.
%
% KEY-VALUE PAIRS
%   'lmax'  The maximum degree harmonic coefficient to compute. Optional if
%           inferrable by alm_getlmmax().
%
%   'mmax'  The maximum order harmonic coefficient to compute. Optional if
%           inferrable by alm_getlmmax().
%
% OUTPUTS
%   map     An Nx3 matrix of map pixel values. Each of the columns are:
%             1. The synthesized map from the given alms.
%             2. The derivative map d(map)/d(theta).
%             3. The derivative map d(map)/d(phi) / sin(theta).
%
% EXAMPLE

  p = inputParser();
  addParameter(p, 'lmax', [], @(x) isnumeric(x) & isscalar(x));
  addParameter(p, 'mmax', [], @(x) isnumeric(x) & isscalar(x));
  parse(p, varargin{:});
  opt = p.Results;

  [lmax, mmax] = @CLASSPREFIX@alm_getlmmax(alms, opt.lmax, opt.mmax);

  if size(alms, 2) ~= 1
    error('alm2map_der1: Expected alms to have size 1 in second dimension, got %d', ...
        size(alms, 2));
  end

  [map, mapdth, mapdph] = libhealmex(int64(56), ...
      int32(lmax), int32(mmax), complex(double(alms)), ...
      int64(nside));
  maps = [map mapdth mapdph];
end
